//example of some shaders compiled
flat basic.vs flat.fs
texture basic.vs texture.fs
depth quad.vs depth.fs
multi basic.vs multi.fs
light basic.vs light.fs
singlepass basic.vs singlepass.fs
normal basic.vs normal.fs
normalmap basic.vs normalmap.fs
uvs basic.vs uvs.fs
metallic basic.vs metallic.fs
gbuffers basic.vs gbuffers.fs
deferred quad.vs deferred.fs

\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;
in vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;
out vec2 v_uv;

void main()
{	
	v_uv = a_coord;
	gl_Position = vec4( a_vertex, 1.0 );
}


\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}


\texture.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	FragColor = color;
}


\lightParameters
uniform vec3 u_ambient_light;
uniform int u_light_type;
uniform vec3 u_light_position;
uniform vec3 u_light_vector;
uniform vec3 u_light_color;
uniform float u_light_intensity;
uniform float u_spot_cosine_cutoff;
uniform float u_spot_exponent;
uniform float u_light_max_distance;
uniform float u_shadow_bias;
uniform bool u_cast_shadow;
uniform mat4 u_shadow_viewproj;

\lightFunctions
mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
	// get edge vectors of the pixel triangle
	vec3 dp1 = dFdx( p );
	vec3 dp2 = dFdy( p );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	
	// solve the linear system
	vec3 dp2perp = cross( dp2, N );
	vec3 dp1perp = cross( N, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
	// construct a scale-invariant frame 
	float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
	return mat3( T * invmax, B * invmax, N );
}

//assume N, the interpolated vertex normal and 
// WP the world position
// vec3 normal_pixel = texture( normalmap, uv ).xyz; 
vec3 perturbNormal(vec3 N, vec3 WP, vec2 uv, vec3 normal_pixel)
{
	normal_pixel = normal_pixel * 255./127. - 128./127.;
	mat3 TBN = cotangent_frame(N, WP, uv);
	return normalize(TBN * normal_pixel);
}

//compute a linear attenuation factor
float computeAttenuationFactor( int light_type, vec3 light_pos, vec3 world_pos, float light_max_dist )
{
	//do not apply if directional light
	if (light_type == 0)
	{
		return 1.0;
	}

	//compute distance
	float light_distance = length( light_pos - world_pos );

	//compute a linear attenuation factor
	float att_factor = light_max_dist - light_distance;

	//normalize factor
	att_factor /= light_max_dist;

	//ignore negative values
	return max( att_factor, 0.0 );
}

vec3 computeLightFromType( int light_type, vec3 light_pos, vec3 world_pos, vec3 light_vector, float spot_cosine_cutoff, float spot_exponent )
{
	if ( light_type == 0)	//directional light
	{
		return normalize(-light_vector);	//same for all pixels
	}
	
	//point and spot light
	vec3 L = vec3(0.0);

	//vector from the point to the light
	L = light_pos - world_pos;

	//we ignore the light distance for now
	L = normalize(L);

	if ( light_type == 1 )	//spot light
	{
		float spotFactor = 1;

		vec3 D = normalize(light_vector);
		float spotCosine = dot(D,-L);
		if (spotCosine >= spot_cosine_cutoff) { 
			spotFactor = pow(spotCosine,spot_exponent);
		} else {
			spotFactor = 0;
		}

		L *= spotFactor;
	} 
		
	return L;
}

float computeShadowFactor(vec3 pos, mat4 u_shadow_viewproj, float u_shadow_bias, sampler2D shadowmap, int u_light_type )
{
	//project our 3D position to the shadowmap
	vec4 proj_pos = u_shadow_viewproj * vec4(pos,1.0);

	//from homogeneus space to clip space
	vec2 shadow_uv = proj_pos.xy / proj_pos.w;

	//from clip space to uv space
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);

	//get point depth [-1 .. +1] in non-linear space
	float real_depth = (proj_pos.z - u_shadow_bias) / proj_pos.w;

	//normalize from [-1..+1] to [0..+1] still non-linear
	real_depth = real_depth * 0.5 + 0.5;

	//read depth from depth buffer in [0..+1] non-linear
	float shadow_depth = texture( shadowmap, shadow_uv).x;

	//compute final shadow factor by comparing
	float shadow_factor = 1.0;

	//we can compare them, even if they are not linear
	if( shadow_depth < real_depth )
		shadow_factor = 0.0;

	//for directional lights
	if ( u_light_type == 0 )
	{
		//if it is outside on the sides
		if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0 )
			return 1.0;

		//it is before near or behind far plane
		if(real_depth < 0.0 || real_depth > 1.0)
			return 1.0;
	}
	else 
	{
		//for spot and point
		//if it is outside on the sides
		if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0 )
			return 0.0;

		//it is before near or behind far plane
		if(real_depth < 0.0 || real_depth > 1.0)
			return 0.0;
	}

	return shadow_factor;
}

vec3 computeLight( vec3 N, int light_type, vec3 light_pos, vec3 world_pos, vec3 light_vector, float spot_cosine_cutoff, float spot_exponent, float light_max_distance, float light_intensity, vec3 light_color )
{
	vec3 sublight = vec3(0.0);

	//select type of light
	vec3 L = computeLightFromType( light_type, light_pos, world_pos, light_vector, spot_cosine_cutoff, spot_exponent );

	//compute how much is aligned
	float NdotL = dot(N,L);
	NdotL = clamp( NdotL, 0.0, 1.0 );

	//attenuation
	float att_factor = computeAttenuationFactor(light_type, light_pos, world_pos, light_max_distance);

	//amount of light
	sublight += ( NdotL * light_color) * att_factor;
	sublight *= light_intensity;
	//IMP missing occlusion texture
	
	return sublight;
}


\light.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_emissive_texture;
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_shadowmap_texture;

uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec3 u_camera_position;

uniform bool u_is_emissor;
uniform bool u_has_metallic_roughness;
uniform bool u_has_normal;
uniform vec3 u_emissive_factor;

#include "lightParameters"

out vec4 FragColor;

#include "lightFunctions"

void main()
{
	//texture coordinates
	vec2 uv = v_uv; 
	
	//get color from the texture
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	//normal
	vec3 N = vec3(0.0);

	if (u_has_normal)
	{
		vec3 normal_pixel = texture( u_normal_texture, v_uv ).xyz;
		N = perturbNormal( normalize( v_normal ) , v_world_position, uv, normal_pixel);
	} else {
		N = normalize( v_normal );
	}

	float occlusion = 1.0;
	if(u_has_metallic_roughness){
		float occlusion = texture( u_metallic_roughness_texture, v_uv ).x;
	}

	//amount of light
	vec3 light = u_ambient_light * occlusion;
	vec3 sublight = vec3(0.0);
	sublight += computeLight( N, u_light_type, u_light_position, v_world_position, u_light_vector, u_spot_cosine_cutoff, u_spot_exponent, u_light_max_distance, u_light_intensity, u_light_color );
	sublight *= occlusion;

	//apply the light to the pixel color 
	vec4 final_color = color;
	
	if (u_cast_shadow)
	{
		float shadow = 0.0;
		for(int x = -1; x <= 1; x++)
		{
			for(int y = -1; y <= 1; y++)
			{
				vec3 pos = v_world_position;
				pos.x += x;
				pos.y += y;
				shadow += computeShadowFactor(pos, u_shadow_viewproj, u_shadow_bias, u_shadowmap_texture, u_light_type );
			}
		}
		shadow /= 9.0;
		sublight *= shadow;

	}
	light += sublight;
	final_color.xyz *= light;

	if (u_is_emissor) 
	{
		vec4 emissive = texture( u_emissive_texture, v_uv );
		emissive.xyz *= u_emissive_factor.xyz;
		final_color.xyz += emissive.xyz;
	}

	FragColor = final_color;
}


\singlepass.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emissive_texture;
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_normal_texture;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec3 u_ambient_light;
uniform vec3 u_camera_position;

uniform bool u_is_emissor;
uniform bool u_has_metallic_roughness;
uniform vec3 u_emissive_factor;
uniform bool u_has_normal;
uniform float u_spot_cosine_cutoff;
uniform float u_spot_exponent;

const int MAX_LIGHTS = 5;
uniform vec3 u_light_pos[MAX_LIGHTS];
uniform vec3 u_light_color[MAX_LIGHTS];
uniform float u_light_intensity[MAX_LIGHTS];
uniform float u_light_max_distance[MAX_LIGHTS];
uniform vec2 u_light_spot_vars[MAX_LIGHTS];
uniform int u_light_type[MAX_LIGHTS];
uniform vec3 u_light_vector[MAX_LIGHTS];
uniform int u_num_lights;

out vec4 FragColor;

#include "lightFunctions"

void main()
{
	//texture coordinates
	vec2 uv = v_uv; 
	
	//get color from the texture
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	//normal
	vec3 N = vec3(0.0);
	if (u_has_normal)
	{
		vec3 normal_pixel = texture( u_normal_texture, v_uv ).xyz;
		N = perturbNormal( normalize( v_normal ) , v_world_position, uv, normal_pixel);
	} else {
		N = normalize( v_normal );
	}

	float occlusion = 1.0;
	if(u_has_metallic_roughness){
		float occlusion = texture( u_metallic_roughness_texture, v_uv ).x;
	}

	//amount of light
	vec3 light = u_ambient_light * occlusion;

	for( int i = 0; i < MAX_LIGHTS; ++i )
	{
		if(i < u_num_lights)
		{
			vec3 sublight = vec3(0.0);
			sublight += computeLight( N, u_light_type[i], u_light_pos[i], v_world_position, u_light_vector[i], u_light_spot_vars[i].x, u_light_spot_vars[i].y, u_light_max_distance[i], u_light_intensity[i], u_light_color[i] );
			sublight *= occlusion;

			light += sublight;
		}
	}

	//apply the light to the pixel color 
	vec4 final_color = color;
	final_color.xyz *= light;

	if (u_is_emissor) {
		vec4 emissive = texture( u_emissive_texture, v_uv );
		emissive.xyz *= u_emissive_factor.xyz;
		final_color.xyz += emissive.xyz;
	}

	FragColor = final_color;
}


\multi.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	FragColor = color;
	NormalColor = vec4(N,1.0);
}

\gbuffers.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec2 u_camera_nearfar;

uniform sampler2D u_texture;
uniform sampler2D u_emissive_texture;
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_normal_texture;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;
layout(location = 2) out vec4 ExtraColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	color.a = 1.0;
	FragColor = color;
	NormalColor = vec4(N * 0.5 + vec3(0.5),1.0);
	ExtraColor = vec4(v_world_position, 1.0);
}

\deferred.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_extra_texture;
uniform sampler2D u_depth_texture;

uniform mat4 u_inverse_viewprojection;

#include "lightParameters"
#include "lightFunctions"

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 albedo = texture( u_color_texture, uv );
	vec4 normal = texture( u_normal_texture, uv);
	vec4 extra = texture( u_extra_texture, uv);
	//vec4 depth = texture( u_depth_texture, uv);

	vec3 N = normalize(normal.xyz * 2.0 - vec3(1.0));
	//vec3 world_position = extra.xyz;
	
	//reconstruct world position from depth and inv. viewproj
	float depth = texture( u_depth_texture, uv ).x;
	//convert in range -1 .. 1
	vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
	//convert clip space coordinate to world position
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;

	//amount of light
	float occlusion = 1.0;
	vec3 light = u_ambient_light * occlusion;
	vec3 sublight = vec3(0.0);
	sublight += computeLight( N, u_light_type, u_light_position, world_position, u_light_vector, u_spot_cosine_cutoff, u_spot_exponent, u_light_max_distance, u_light_intensity, u_light_color );
	sublight *= occlusion;

	light += sublight;
	vec3 color = albedo.xyz;
	color.xyz *= light;

	FragColor = vec4(color,1.0);
}


\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	float color = n * (z + 1.0) / (f + n - z * (f - n));
	FragColor = vec4(color);
}


\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}


\normal.fs

#version 330 core

in vec3 v_normal;

out vec4 FragColor;

void main()
{
	FragColor = vec4( abs(normalize(v_normal)), 1.0 );
}


\normalmap.fs

#version 330 core

in vec3 v_normal;
in vec2 v_uv;

uniform sampler2D u_normal_texture;
uniform bool u_has_normal;

out vec4 FragColor;

void main()
{
	if (!u_has_normal) {
		discard;
	}

	vec3 normalmap_texture = texture( u_normal_texture, v_uv ).xyz;

	FragColor = vec4(normalmap_texture, 1.0);
}


\uvs.fs

#version 330 core

in vec2 v_uv;

out vec4 FragColor;

void main()
{
	FragColor = vec4(v_uv, 1.0, 1.0);
}


\metallic.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_metallic_roughness_texture;
uniform bool u_has_metallic_roughness;
uniform int u_type_property;

out vec4 FragColor;

void main()
{
	if( !u_has_metallic_roughness )
	{
		discard;
	}

	vec2 uv = v_uv;
	float metallic;

	if( u_type_property == 0 ) {		 	 //occlusion
		metallic = texture( u_metallic_roughness_texture, v_uv ).x;
	} else if ( u_type_property == 1) { 	 //metallic
		metallic = texture( u_metallic_roughness_texture, v_uv ).z;
	} else {							     //roughness
		metallic = texture( u_metallic_roughness_texture, v_uv ).y;
	}

	FragColor = vec4(metallic, metallic, metallic, 1.0);
}