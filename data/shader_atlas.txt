//example of some shaders compiled
flat basic.vs flat.fs
texture basic.vs texture.fs
depth quad.vs depth.fs
multi basic.vs multi.fs
light basic.vs light.fs
singlepass basic.vs singlepass.fs
normal basic.vs normal.fs
normalmap basic.vs normalmap.fs
uvs basic.vs uvs.fs
metallic basic.vs metallic.fs
gbuffers basic.vs gbuffers.fs
deferred quad.vs deferred.fs
deferred_ws basic.vs deferred.fs
ssao quad.vs ssao.fs
blur_ssao quad.vs ssao.fs
gbuffers_alpha quad.vs gbuffers_alpha.fs
gamma quad.vs gamma.fs
tone_mapper quad.vs tone_mapper.fs
probe basic.vs probe.fs
skybox basic.vs skybox.fs
reflection basic.vs reflection.fs
volume_direct quad.vs volume_direct.fs
volume_direct_ws basic.vs volume_direct.fs
decals basic.vs decals.fs
irradiance quad.vs irradiance.fs
//PostFX
motion_blur quad.vs motion_blur.fs
pixelated quad.vs pixelated.fs
blur quad.vs blur.fs
dof quad.vs dof.fs
grain quad.vs grain.fs
chromatic quad.vs chromatic.fs
bloom quad.vs bloom.fs
lens quad.vs lens.fs
lut quad.vs lut.fs
fxaa quad.vs fxaa.fs
sharpen quad.vs sharpen.fs

\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;
in vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;
out vec2 v_uv;

void main()
{	
	v_uv = a_coord;
	gl_Position = vec4( a_vertex, 1.0 );
}


\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}


\texture.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	FragColor = color;
}

\irradianceFunctions
vec3 computeIrradiance(vec3 world_pos, vec3 N) {
	//computing nearest probe index based on world position
	vec3 irr_range = u_irr_end - u_irr_start;
	vec3 irr_local_pos = clamp( world_pos - u_irr_start + N * u_irr_normal_distance, vec3(0.0), irr_range );

	//convert from world pos to grid pos
	vec3 irr_norm_pos = irr_local_pos / u_irr_delta;

	//round values as we cannot fetch between rows for now
	vec3 local_indices = round( irr_norm_pos );

	//compute in which row is the probe stored
	float row = local_indices.x + local_indices.y * u_irr_dims.x + local_indices.z * u_irr_dims.x * u_irr_dims.y;

	//find the UV.y coord of that row in the probes texture
	float row_uv = (row + 1.0) / (u_num_probes + 1.0);

	SH9Color sh;

	//fill the coefficients
	const float d_uvx = 1.0 / 9.0;
	for(int i = 0; i < 9; ++i)
	{
		vec2 coeffs_uv = vec2( (float(i)+0.5) * d_uvx, row_uv );
		sh.c[i] = texture( u_probes_texture, coeffs_uv).xyz;
	}
	
	//now we can use the coefficients to compute the irradiance
	return ComputeSHIrradiance( N, sh );
}

vec3 computeIrr( vec3 indices, vec3 N ) {
	//compute in which row is the probe stored
	float row = indices.x + indices.y * u_irr_dims.x + indices.z * u_irr_dims.x * u_irr_dims.y;

	//find the UV.y coord of that row in the probes texture
	float row_uv = (row + 1.0) / (u_num_probes + 1.0);

	SH9Color sh;

	//fill the coefficients
	const float d_uvx = 1.0 / 9.0;
	for(int i = 0; i < 9; ++i)
	{
		vec2 coeffs_uv = vec2( (float(i)+0.5) * d_uvx, row_uv );
		sh.c[i] = texture( u_probes_texture, coeffs_uv).xyz;
	}
	
	//now we can use the coefficients to compute the irradiance
	return ComputeSHIrradiance( N, sh );
}

vec3 computeIrradianceInterpolated(vec3 world_pos, vec3 N) {
	//computing nearest probe index based on world position
	vec3 irr_range = u_irr_end - u_irr_start;
	vec3 irr_local_pos = clamp( world_pos - u_irr_start + N * u_irr_normal_distance, vec3(0.0), irr_range );

	//convert from world pos to grid pos
	vec3 irr_norm_pos = irr_local_pos / u_irr_delta;

	//round values as we cannot fetch between rows for now
	vec3 local_indices = floor( irr_norm_pos );

	//now we have the interpolation factors
	vec3 factors = irr_norm_pos - local_indices; 

	//trilinear interpolation
	//local_indices points to left bottom far
	vec3 indicesLBF = local_indices;

	//left top far
	vec3 indicesLTF = local_indices;
	indicesLTF.y += 1;

	//left bottom near
	vec3 indicesLBN = local_indices;
	indicesLBN.z += 1;

	//left top near
	vec3 indicesLTN = local_indices;
	indicesLTN.z += 1;
	indicesLTN.y += 1;

	//right bottom far
	vec3 indicesRBF = local_indices;
	indicesRBF.x += 1;

	//right top far
	vec3 indicesRTF = local_indices;
	indicesRTF.x += 1;
	indicesRTF.y += 1;

	//right bottom near
	vec3 indicesRBN = local_indices;
	indicesRBN.x += 1;
	indicesRBN.z += 1;

	//right top near
	vec3 indicesRTN = local_indices;
	indicesRTN.x += 1;
	indicesRTN.y += 1;
	indicesRTN.z += 1;
	
	//compute irradiance for every corner
	vec3 irrLBF = computeIrr( indicesLBF, N );
	vec3 irrRBF = computeIrr( indicesRBF, N );
	vec3 irrLTF = computeIrr( indicesLTF, N );
	vec3 irrRTF = computeIrr( indicesRTF, N );
	vec3 irrLBN = computeIrr( indicesLBN, N );
	vec3 irrRBN = computeIrr( indicesRBN, N );
	vec3 irrLTN = computeIrr( indicesLTN, N );
	vec3 irrRTN = computeIrr( indicesRTN, N );

	vec3 irrTF = mix( irrLTF, irrRTF, factors.x );
	vec3 irrBF = mix( irrLBF, irrRBF, factors.x );
	vec3 irrTN = mix( irrLTN, irrRTN, factors.x );
	vec3 irrBN = mix( irrLBN, irrRBN, factors.x );

	vec3 irrT = mix( irrTF, irrTN, factors.z );
	vec3 irrB = mix( irrBF, irrBN, factors.z );
	
	vec3 irr = mix( irrB, irrT, factors.y );

	return irr;
}

\lightUniforms
uniform vec3 u_ambient_light;
uniform int u_light_type;
uniform vec3 u_light_position;
uniform vec3 u_light_vector;
uniform vec3 u_light_color;
uniform float u_light_intensity;
uniform float u_spot_cosine_cutoff;
uniform float u_spot_exponent;
uniform float u_light_max_distance;
uniform float u_shadow_bias;
uniform bool u_cast_shadow;
uniform mat4 u_shadow_viewproj;

\normalMapping
mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
	// get edge vectors of the pixel triangle
	vec3 dp1 = dFdx( p );
	vec3 dp2 = dFdy( p );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	
	// solve the linear system
	vec3 dp2perp = cross( dp2, N );
	vec3 dp1perp = cross( N, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
	// construct a scale-invariant frame 
	float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
	return mat3( T * invmax, B * invmax, N );
}

//assume N, the interpolated vertex normal and 
// WP the world position
// vec3 normal_pixel = texture( normalmap, uv ).xyz; 
vec3 perturbNormal(vec3 N, vec3 WP, vec2 uv, vec3 normal_pixel)
{
	normal_pixel = normal_pixel * 255./127. - 128./127.;
	mat3 TBN = cotangent_frame(N, WP, uv);
	return normalize(TBN * normal_pixel);
}

\lightFunctions
//compute a linear attenuation factor
float computeAttenuationFactor( int light_type, vec3 light_pos, vec3 world_pos, float light_max_dist )
{
	//do not apply if directional light
	if (light_type == 0)
	{
		return 1.0;
	}

	//compute distance
	float light_distance = length( light_pos - world_pos );

	//compute a linear attenuation factor
	float att_factor = light_max_dist - light_distance;

	//normalize factor
	att_factor /= light_max_dist;

	//ignore negative values
	return max( att_factor, 0.0 );
}

vec3 computeLightFromType( int light_type, vec3 light_pos, vec3 world_pos, vec3 light_vector, float spot_cosine_cutoff, float spot_exponent )
{
	if ( light_type == 0)	//directional light
	{
		return normalize(-light_vector);	//same for all pixels
	}
	
	//point and spot light
	vec3 L = vec3(0.0);

	//vector from the point to the light
	L = light_pos - world_pos;

	//we ignore the light distance for now
	L = normalize(L);

	if ( light_type == 1 )	//spot light
	{
		float spotFactor = 1;

		vec3 D = normalize(light_vector);
		float spotCosine = dot(D,-L);
		if (spotCosine >= spot_cosine_cutoff) { 
			spotFactor = pow(spotCosine,spot_exponent);
		} else {
			spotFactor = 0;
		}

		L *= spotFactor;
	} 
		
	return L;
}

float computeShadowFactor(vec3 pos, mat4 u_shadow_viewproj, float u_shadow_bias, sampler2D shadowmap, int u_light_type )
{
	//project our 3D position to the shadowmap
	vec4 proj_pos = u_shadow_viewproj * vec4(pos,1.0);

	//from homogeneus space to clip space
	vec2 shadow_uv = proj_pos.xy / proj_pos.w;

	//from clip space to uv space
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);

	//get point depth [-1 .. +1] in non-linear space
	float real_depth = (proj_pos.z - u_shadow_bias) / proj_pos.w;

	//normalize from [-1..+1] to [0..+1] still non-linear
	real_depth = real_depth * 0.5 + 0.5;

	//read depth from depth buffer in [0..+1] non-linear
	float shadow_depth = texture( shadowmap, shadow_uv).x;

	//compute final shadow factor by comparing
	float shadow_factor = 1.0;

	//we can compare them, even if they are not linear
	if( shadow_depth < real_depth )
		shadow_factor = 0.0;

	//for directional lights
	if ( u_light_type == 0 )
	{
		//if it is outside on the sides
		if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0 )
			return 1.0;

		//it is before near or behind far plane
		if(real_depth < 0.0 || real_depth > 1.0)
			return 1.0;
	}
	else 
	{
		//for spot and point
		//if it is outside on the sides
		if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0 )
			return 0.0;

		//it is before near or behind far plane
		if(real_depth < 0.0 || real_depth > 1.0)
			return 0.0;
	}

	return shadow_factor;
}

vec3 computeLight( vec3 N, int light_type, vec3 light_pos, vec3 world_pos, vec3 light_vector, float spot_cosine_cutoff, float spot_exponent, float light_max_distance, float light_intensity, vec3 light_color )
{
	vec3 sublight = vec3(0.0);

	//select type of light
	vec3 L = computeLightFromType( light_type, light_pos, world_pos, light_vector, spot_cosine_cutoff, spot_exponent );

	//compute how much is aligned
	float NdotL = dot(N,L);
	NdotL = clamp( NdotL, 0.0, 1.0 );

	//attenuation
	float att_factor = computeAttenuationFactor(light_type, light_pos, world_pos, light_max_distance);

	//amount of light
	sublight += ( NdotL * light_color) * att_factor;
	sublight *= light_intensity;
	
	return sublight;
}

#define PI 3.1415926535897932384626433832795

//Normal Distribution Function using GGX Distribution
float D_GGX ( float NoH, float linearRoughness )
{
	float a2 = linearRoughness * linearRoughness;
	float f = (NoH * NoH) * (a2 - 1.0) + 1.0;
	return a2 / (PI * f * f);
}

//Fresnel term with colorized fresnel
vec3 F_Schlick( float VoH, vec3 f0)
{
	float f = pow(1.0 - VoH, 5.0);
	return f0 + (vec3(1.0) - f0) * f;
}

//Geometry visibility
float GGX(float NdotV, float k){
	return NdotV / (NdotV * (1.0 - k) + k);
}
	
float G_Smith( float NdotV, float NdotL, float roughness)
{
	float k = pow(roughness + 1.0, 2.0) / 8.0;
	return GGX(NdotL, k) * GGX(NdotV, k);
}

//cook torrance specular reflection model
vec3 specularBRDF( float roughness, vec3 f0, float NoH, float NoV, float NoL, float LoH )
{
	float a = roughness * roughness;

	// Normal Distribution Function
	float D = D_GGX( NoH, a );

	// Fresnel Function
	vec3 F = F_Schlick( LoH, f0 );

	// Visibility Function (shadowing/masking)
	float G = G_Smith( NoV, NoL, roughness );
		
	// Norm factor
	vec3 spec = D * G * F;
	spec /= (4.0 * NoL * NoV + 1e-6);

	return spec;
}

float F_Schlick2(float u, float f0, float f90) {
    return f0 + (f90 - f0) * pow(1.0 - u, 5.0);
}

#define RECIPROCAL_PI 0.3183098861837697

// Diffuse Reflections: Disney BRDF using retro-reflections using F term, this is much more complex!!
float Fd_Burley ( const in float NoV, const in float NoL, const in float LoH, const in float linearRoughness )
{
        float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;
        float lightScatter = F_Schlick2( NoL, 1.0, f90 );
        float viewScatter  = F_Schlick2( NoV, 1.0, f90 );
        return lightScatter * viewScatter * RECIPROCAL_PI;
}

vec3 computePBR(vec3 baseColor, float metalness, float roughness, vec3 camera_pos, vec3 N, int light_type, vec3 light_pos, vec3 world_pos, vec3 light_vector, float spot_cosine_cutoff, float spot_exponent, float light_max_distance, float light_intensity, vec3 light_color)
{
	vec3 sublight = vec3(0.0);

	//L: vector toward the light
	vec3 L = computeLightFromType( light_type, light_pos, world_pos, light_vector, spot_cosine_cutoff, spot_exponent );

	//compute how much is aligned
	float NdotL = clamp( dot(N,L), 0.0, 1.0 );

	//V: vector towards eye
	vec3 V = normalize(camera_pos - world_pos);
	float NdotV = clamp( dot(N,V), 0.0, 1.0 );
	
	//H: half vector between V and L
	vec3 H = normalize(V + L);
	float NdotH = clamp( dot(N,H), 0.0, 1.0 );

	float LdotH = clamp( dot(L,H), 0.0, 1.0 );
	
	//compute the reflection (fresnel) based on the color and the metalness
	vec3 fresnel = mix( vec3(0.5), baseColor.xyz, metalness );

	//compute specular 
	vec3 specular = NdotL * specularBRDF( roughness, fresnel, NdotH, NdotV, NdotL, LdotH );

	//metallic materials do not have diffuse
	vec3 diffuseColor = (1.0 - metalness) * baseColor.xyz;

	//compute diffuse
	vec3 diffuse = diffuseColor * NdotL;
	
	//float linearRoughness = pow(roughness, 2.0);
	//vec3 diffuse = diffuseColor * Fd_Burley(NdotV, NdotL, LdotH, linearRoughness); 


	//attenuation
	float att_factor = computeAttenuationFactor(light_type, light_pos, world_pos, light_max_distance);
	//shadow factor is missing
	vec3 properties = light_color * light_intensity * att_factor;
	
	//add diffuse + specular
	vec3 direct = diffuse + specular;

	sublight += direct * properties;
	return sublight;
}

\light.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_emissive_texture;
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_shadowmap_texture;
uniform samplerCube u_environment_texture;
uniform samplerCube u_reflection_texture;

uniform bool u_last_pass;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec3 u_camera_position;

uniform bool u_has_environment;
uniform bool u_is_emissor;
uniform bool u_has_metallic_roughness;
uniform bool u_has_normal;
uniform vec3 u_emissive_factor;
uniform bool u_linear_correction;
uniform float u_gamma;

#include "lightUniforms"

out vec4 FragColor;

#include "lightFunctions"
#include "normalMapping"

void main()
{
	//texture coordinates
	vec2 uv = v_uv; 
	
	//get color from the texture
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	//normal
	vec3 N = vec3(0.0);

	if (u_has_normal)
	{
		vec3 normal_pixel = texture( u_normal_texture, v_uv ).xyz;
		N = perturbNormal( normalize( v_normal ) , v_world_position, uv, normal_pixel);
	} else {
		N = normalize( v_normal );
	}

	float occlusion = 1.0;
	if(u_has_metallic_roughness){
		float occlusion = texture( u_metallic_roughness_texture, v_uv ).x;
	}

	float roughness = 1.0;
	float metalness = 0.0;
	if(u_has_metallic_roughness) 
	{
		roughness = texture( u_metallic_roughness_texture, v_uv ).y;
		metalness = texture( u_metallic_roughness_texture, v_uv ).z;
	}

	vec3 light_color = u_light_color;
	vec3 ambient_light = u_ambient_light;
	vec4 emissive = vec4(0.0);
	if(u_linear_correction) 
	{
		color.xyz = pow(color.xyz,vec3(u_gamma));
		light_color = pow(u_light_color,vec3(u_gamma));
		ambient_light = pow(ambient_light,vec3(u_gamma));

		if (u_is_emissor) 
		{
			emissive = texture( u_emissive_texture, v_uv );
			emissive.xyz *= u_emissive_factor.xyz;
			emissive.xyz = pow(emissive.xyz,vec3(u_gamma));
		}
	}

	//amount of light
	vec3 light = ambient_light * occlusion;
	vec3 sublight = vec3(0.0);

	//Phong
	//sublight += computeLight( N, u_light_type, u_light_position, v_world_position, u_light_vector, u_spot_cosine_cutoff, u_spot_exponent, u_light_max_distance, u_light_intensity, light_color );
	
	//PBR
	sublight += computePBR(color.xyz, metalness, roughness, u_camera_position, N, u_light_type, u_light_position, v_world_position, u_light_vector, u_spot_cosine_cutoff, u_spot_exponent, u_light_max_distance, u_light_intensity, light_color);
	

	sublight *= occlusion;

	//apply the light to the pixel color 
	vec4 final_color = color;
	
	if (u_cast_shadow)
	{
		float shadow = 0.0;
		for(int x = -1; x <= 1; x++)
		{
			for(int y = -1; y <= 1; y++)
			{
				vec3 pos = v_world_position;
				pos.x += x;
				pos.y += y;
				shadow += computeShadowFactor(pos, u_shadow_viewproj, u_shadow_bias, u_shadowmap_texture, u_light_type );
			}
		}
		shadow /= 9.0;
		sublight *= shadow;

	}
	light += sublight;
	final_color.xyz *= light;

	if (u_is_emissor) 
	{
		if(!u_linear_correction)
		{
			emissive = texture( u_emissive_texture, v_uv );
			emissive.xyz *= u_emissive_factor.xyz;
		}
		final_color.xyz += emissive.xyz;
	}

	vec3 V = v_world_position - u_camera_position;
	vec3 R = reflect( V, N );

	if(u_last_pass)
	{
		final_color.xyz += textureLod( u_reflection_texture, R, roughness * 3.0 ).xyz * metalness;
	}

	FragColor = final_color;
}


\singlepass.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_emissive_texture;
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_normal_texture;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec3 u_ambient_light;
uniform vec3 u_camera_position;

uniform bool u_is_emissor;
uniform bool u_has_metallic_roughness;
uniform vec3 u_emissive_factor;
uniform bool u_has_normal;
uniform float u_spot_cosine_cutoff;
uniform float u_spot_exponent;

const int MAX_LIGHTS = 5;
uniform vec3 u_light_pos[MAX_LIGHTS];
uniform vec3 u_light_color[MAX_LIGHTS];
uniform float u_light_intensity[MAX_LIGHTS];
uniform float u_light_max_distance[MAX_LIGHTS];
uniform vec2 u_light_spot_vars[MAX_LIGHTS];
uniform int u_light_type[MAX_LIGHTS];
uniform vec3 u_light_vector[MAX_LIGHTS];
uniform int u_num_lights;

out vec4 FragColor;

#include "lightFunctions"
#include "normalMapping"

void main()
{
	//texture coordinates
	vec2 uv = v_uv; 
	
	//get color from the texture
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	//normal
	vec3 N = vec3(0.0);
	if (u_has_normal)
	{
		vec3 normal_pixel = texture( u_normal_texture, v_uv ).xyz;
		N = perturbNormal( normalize( v_normal ) , v_world_position, uv, normal_pixel);
	} else {
		N = normalize( v_normal );
	}

	float occlusion = 1.0;
	float roughness = 1.0;
	float metalness = 0.0;
	if(u_has_metallic_roughness){
		occlusion = texture( u_metallic_roughness_texture, v_uv ).x;
		roughness = texture( u_metallic_roughness_texture, v_uv ).y;
		metalness = texture( u_metallic_roughness_texture, v_uv ).z;
	}

	//amount of light
	vec3 light = u_ambient_light * occlusion;

	for( int i = 0; i < MAX_LIGHTS; ++i )
	{
		if(i < u_num_lights)
		{
			vec3 sublight = vec3(0.0);
			//sublight += computeLight( N, u_light_type[i], u_light_pos[i], v_world_position, u_light_vector[i], u_light_spot_vars[i].x, u_light_spot_vars[i].y, u_light_max_distance[i], u_light_intensity[i], u_light_color[i] );
			//PBR
			sublight += computePBR(color.xyz, metalness, roughness, u_camera_position, N, u_light_type[i], u_light_pos[i], v_world_position, u_light_vector[i], u_light_spot_vars[i].x, u_light_spot_vars[i].y, u_light_max_distance[i], u_light_intensity[i], u_light_color[i]);
	
			sublight *= occlusion;

			light += sublight;
		}
	}

	//apply the light to the pixel color 
	vec4 final_color = color;
	final_color.xyz *= light;

	if (u_is_emissor) {
		vec4 emissive = texture( u_emissive_texture, v_uv );
		emissive.xyz *= u_emissive_factor.xyz;
		final_color.xyz += emissive.xyz;
	}

	FragColor = final_color;
}


\multi.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	FragColor = color;
	NormalColor = vec4(N,1.0);
}

\gbuffers.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec2 u_camera_nearfar;
uniform vec3 u_camera_position;

uniform sampler2D u_texture;
uniform sampler2D u_emissive_texture;
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_ssao_texture;
uniform samplerCube u_reflection_texture;

uniform bool u_last_pass;
uniform bool u_apply_dithering;
uniform bool u_has_normal;
uniform bool u_has_metallic_roughness;
uniform bool u_is_emissor;
uniform bool u_has_ssao;
uniform vec3 u_emissive_factor;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;
layout(location = 2) out vec4 ExtraColor;

#include "normalMapping"

float dither4x4(vec2 position, float brightness)
{
  int x = int(mod(position.x, 4.0));
  int y = int(mod(position.y, 4.0));
  int index = x + y * 4;
  float limit = 0.0;

  if (x < 8) {
    if (index == 0) limit = 0.0625;
    if (index == 1) limit = 0.5625;
    if (index == 2) limit = 0.1875;
    if (index == 3) limit = 0.6875;
    if (index == 4) limit = 0.8125;
    if (index == 5) limit = 0.3125;
    if (index == 6) limit = 0.9375;
    if (index == 7) limit = 0.4375;
    if (index == 8) limit = 0.25;
    if (index == 9) limit = 0.75;
    if (index == 10) limit = 0.125;
    if (index == 11) limit = 0.625;
    if (index == 12) limit = 1.0;
    if (index == 13) limit = 0.5;
    if (index == 14) limit = 0.875;
    if (index == 15) limit = 0.375;
  }

  return brightness < limit ? 0.0 : 1.0;
}

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	if(u_apply_dithering)
	{
		if(dither4x4(gl_FragCoord.xy, color.a) == 0.0)
			discard;
		//if(color.a < 0.9 && floor(mod(gl_FragCoord.x,2.0)) != floor(mod(gl_FragCoord.y,2.0)) )
		//discard;
	}

	//normal
	vec3 N = vec3(0.0);
	if (u_has_normal)
	{
		vec3 normal_pixel = texture( u_normal_texture, v_uv ).xyz;
		N = perturbNormal( normalize( v_normal ) , v_world_position, uv, normal_pixel);
	} else {
		N = normalize( v_normal );
	}

	//metallic roughness
	vec3 metallic = vec3(1.0, 1.0, 0.0);	//occlusion, roughness, metallic
	if (u_has_metallic_roughness)
	{
		metallic = texture( u_metallic_roughness_texture, uv ).xyz;
	}

	//emissive
	vec3 emissive = vec3(0.0);
	if (u_is_emissor) {
		emissive = texture( u_emissive_texture, v_uv ).xyz;
		emissive.xyz *= u_emissive_factor.xyz;
	}
	
	if(u_last_pass) {
		vec3 V = v_world_position - u_camera_position;
		vec3 R = reflect( V, N );
		emissive.xyz += textureLod( u_reflection_texture, R, metallic.y * 1.0 ).xyz * metallic.z;
	}

	float occlusion = 0.0;
	//get occlusion from ssao texture
	if(u_has_ssao)
	{
		occlusion = texture( u_ssao_texture, uv ).x;
	} else {
		occlusion = metallic.x;
	}

	//albedo + roughness
	FragColor = vec4(color.xyz, metallic.y);
	//normalmap + occlusion
	NormalColor = vec4(N * 0.5 + vec3(0.5), occlusion);
	//emissive + metallic
	ExtraColor = vec4(emissive, metallic.z);
}

\SHfunctions
const float Pi = 3.141592654;
const float CosineA0 = Pi;
const float CosineA1 = (2.0 * Pi) / 3.0;
const float CosineA2 = Pi * 0.25;
struct SH9 { float c[9]; }; //to store weights
struct SH9Color { vec3 c[9]; }; //to store colors

void SHCosineLobe(in vec3 dir, out SH9 sh) //SH9
{
	// Band 0
	sh.c[0] = 0.282095 * CosineA0;
	// Band 1
	sh.c[1] = 0.488603 * dir.y * CosineA1; 
	sh.c[2] = 0.488603 * dir.z * CosineA1;
	sh.c[3] = 0.488603 * dir.x * CosineA1;
	// Band 2
	sh.c[4] = 1.092548 * dir.x * dir.y * CosineA2;
	sh.c[5] = 1.092548 * dir.y * dir.z * CosineA2;
	sh.c[6] = 0.315392 * (3.0 * dir.z * dir.z - 1.0) * CosineA2;
	sh.c[7] = 1.092548 * dir.x * dir.z * CosineA2;
	sh.c[8] = 0.546274 * (dir.x * dir.x - dir.y * dir.y) * CosineA2;
}

vec3 ComputeSHIrradiance(in vec3 normal, in SH9Color sh)
{
	// Compute the cosine lobe in SH, oriented about the normal direction
	SH9 shCosine;
	SHCosineLobe(normal, shCosine);
	// Compute the SH dot product to get irradiance
	vec3 irradiance = vec3(0.0);
	for(int i = 0; i < 9; ++i)
		irradiance += sh.c[i] * shCosine.c[i];

	return irradiance;
}

\deferred.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_extra_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_shadowmap_texture;
uniform sampler2D u_ssao_texture;
uniform samplerCube u_environment_texture;

uniform vec2 u_iRes;
uniform vec3 u_camera_position;
uniform bool u_render_shadows;
uniform bool u_is_emissor;
uniform bool u_has_ssao;
uniform bool u_linear_correction;

uniform bool u_last_pass;
uniform float u_gamma;
uniform mat4 u_inverse_viewprojection;
uniform bool u_has_environment;
uniform bool u_apply_irradiance;
uniform sampler2D u_probes_texture;

uniform vec3 u_irr_start;
uniform vec3 u_irr_end;
uniform vec3 u_irr_dims; 
uniform vec3 u_irr_delta;
uniform float u_num_probes;
uniform float u_irr_normal_distance;

#include "lightUniforms"
#include "lightFunctions"
#include "SHfunctions"
#include "irradianceFunctions"

out vec4 FragColor;

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	vec4 albedo = texture( u_color_texture, uv );
	vec4 normal = texture( u_normal_texture, uv);
	vec4 extra = texture( u_extra_texture, uv);

	vec3 N = normalize(normal.xyz * 2.0 - vec3(1.0));
	
	//reconstruct world position from depth and inv. viewproj
	float depth = texture( u_depth_texture, uv ).x;
	//convert in range -1 .. 1
	vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
	//convert clip space coordinate to world position
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;

	vec3 light_color = u_light_color;
	vec3 ambient_light = u_ambient_light;
	if(u_linear_correction) 
	{
		albedo.xyz = pow(albedo.xyz,vec3(u_gamma));
		extra.xyz = pow(extra.xyz,vec3(u_gamma));
		light_color = pow(u_light_color,vec3(u_gamma));
		ambient_light = pow(ambient_light,vec3(u_gamma));
	}

	//amount of light
	float occlusion = 0.0;
	//get occlusion from ssao texture
	if(u_has_ssao)
	{
		occlusion = texture( u_ssao_texture, uv ).x;
	}

	vec3 light = u_ambient_light;
	if(u_apply_irradiance) 
	{
		vec3 irradiance = computeIrradianceInterpolated( world_position, N );
		light += irradiance;
	}
	light *= occlusion;
	vec3 sublight = vec3(0.0);
	//sublight += computeLight( N, u_light_type, u_light_position, world_position, u_light_vector, u_spot_cosine_cutoff, u_spot_exponent, u_light_max_distance, u_light_intensity, light_color );
	
	//light using PBR
	float roughness = albedo.a;
	float metalness = extra.a;
	sublight += computePBR(albedo.xyz, metalness, roughness , u_camera_position, N, u_light_type, u_light_position, world_position, u_light_vector, u_spot_cosine_cutoff, u_spot_exponent, u_light_max_distance, u_light_intensity, light_color);
	
	//u_shadow_bias
	if (u_cast_shadow && u_render_shadows)
	{
		float shadow = 0.0;
		for(int x = -1; x <= 1; x++)
		{
			for(int y = -1; y <= 1; y++)
			{
				vec3 pos = world_position;
				pos.x += x;
				pos.y += y;
				shadow += computeShadowFactor(pos, u_shadow_viewproj, u_shadow_bias, u_shadowmap_texture, u_light_type );
			}
		}
		shadow /= 9.0;
		sublight *= shadow;
	}
	sublight *= occlusion;

	if(u_apply_irradiance) {
	//	sublight += computeIrradiance(world_position, N);
	}

	light += sublight;
	vec3 color = albedo.xyz;
	color.xyz *= light;

	//add emissive
	if(u_is_emissor)
	{
		vec3 emissive = extra.xyz;
		color.xyz += emissive.xyz;
	}

	FragColor = vec4(color,1.0);
}


\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	float color = n * (z + 1.0) / (f + n - z * (f - n));
	FragColor = vec4(color);
}


\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}


\normal.fs

#version 330 core

in vec3 v_normal;

out vec4 FragColor;

void main()
{
	FragColor = vec4( abs(normalize(v_normal)), 1.0 );
}


\normalmap.fs

#version 330 core

in vec3 v_normal;
in vec2 v_uv;

uniform sampler2D u_normal_texture;
uniform bool u_has_normal;

out vec4 FragColor;

void main()
{
	if (!u_has_normal) {
		discard;
	}

	vec3 normalmap_texture = texture( u_normal_texture, v_uv ).xyz;

	FragColor = vec4(normalmap_texture, 1.0);
}


\uvs.fs

#version 330 core

in vec2 v_uv;

out vec4 FragColor;

void main()
{
	FragColor = vec4(v_uv, 1.0, 1.0);
}


\metallic.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_metallic_roughness_texture;
uniform bool u_has_metallic_roughness;
uniform int u_type_property;

out vec4 FragColor;

void main()
{
	float metallic = 0.0;
	vec2 uv = v_uv;

	if( u_has_metallic_roughness )
	{
		if( u_type_property == 0 ) {		 	 //occlusion
			metallic = texture( u_metallic_roughness_texture, v_uv ).x;
		} else if ( u_type_property == 1) { 	 //metallic
			metallic = texture( u_metallic_roughness_texture, v_uv ).z;
		} else {							     //roughness
			metallic = texture( u_metallic_roughness_texture, v_uv ).y;
		}
	} else {
		if( u_type_property == 0 ) {		 	 //occlusion
			metallic = 1.0;
		} else if ( u_type_property == 1) { 	 //metallic
			metallic = 0.0;
		} else {							     //roughness
			metallic = 1.0;
		}
	}

	FragColor = vec4(metallic, metallic, metallic, 1.0);
}

\ssao.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_normal_texture;
uniform sampler2D u_depth_texture;
uniform mat4 u_viewprojection;
uniform mat4 u_inverse_viewprojection;
uniform vec2 u_iRes;
uniform vec3 u_points[64];

out vec4 FragColor;

#include "normalMapping"

void main()
{
	float intensity = 1.0;
	//we want to center the sample in the center of the pixel
	vec2 uv = v_uv + u_iRes * 0.5;

	//read depth from depth buffer
	float depth = texture( u_depth_texture, uv ).x;

	//ignore pixels in the background
	if(depth >= 1.0)
	{
		FragColor = vec4(1.0);
		return;
	}

	//create screenpos with the right depth
	vec4 screen_position = vec4(uv*2.0 - vec2(1.0), depth*2.0 - 1.0,1.0);

	//reproject
	vec4 proj_worldpos = u_inverse_viewprojection * screen_position;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;

	//get the normal
	vec3 N = texture( u_normal_texture, uv ).xyz;
	//create the matrix33 to convert from tangent to world
	mat3 rotmat = cotangent_frame( N, worldpos, uv );

	//lets use 64 samples
	const int samples = 64;
	int num = samples; //num samples that passed the are outside

	//for every sample around the point
	for( int i = 0; i < samples; ++i )
	{
		//rotate the point
		vec3 rotated_point = rotmat * u_points[i];

		//compute is world position using the random
		vec3 p = worldpos + rotated_point * 10.0;
		//find the uv in the depth buffer of this point
		vec4 proj = u_viewprojection * vec4(p,1.0);
		proj.xy /= proj.w; //convert to clipspace from homogeneous
		//apply a tiny bias to its z before converting to clip-space
		proj.z = (proj.z - 0.005) / proj.w;
		proj.xyz = proj.xyz * 0.5 + vec3(0.5); //to [0..1]
		//read p true depth
		float pdepth = texture( u_depth_texture, proj.xy ).x;
		//compare true depth with its depth
		if( pdepth < proj.z ) //if true depth smaller, is inside
			num--; //remove this point from the list of visible
	}

	//finally, compute the AO factor as the ratio of visible points
	float ao = float(num) / float(samples);


	FragColor = vec4(ao);
}

\blur_ssao.fs

#version 330 core

in vec2 v_uv;

uniform vec2 u_iRes;
uniform sampler2D u_texture;

out vec4 FragColor;

void main()
{
	//we want to center the sample in the center of the pixel
	vec2 uv = v_uv + u_iRes * 0.5;
	float color = texture( u_texture, v_uv ).x;
	
	vec2 texelSize = 1.0 / vec2(textureSize(u_texture, 0));
    float result = 0.0;
    for (int x = -2; x < 2; ++x) 
    {
        for (int y = -2; y < 2; ++y) 
        {
            vec2 offset = vec2(float(x), float(y)) * texelSize;
            result += texture(u_texture, uv + offset).r;
        }
    }
    //FragColor = result / (4.0 * 4.0);
	FragColor = vec4(1.0,0.0,0.0,1.0);
}

\gbuffers_alpha.fs

#version 330 core

in vec2 v_uv;

uniform vec2 u_iRes;
uniform sampler2D u_texture;

out vec4 FragColor;

void main()
{
	//we want to center the sample in the center of the pixel
	vec2 uv = v_uv + u_iRes * 0.5;
	float color = texture( u_texture, v_uv ).a;
	
	FragColor = vec4(color, color, color, 1.0);
}

\gamma.fs

#version 330 core

in vec2 v_uv;

uniform vec2 u_iRes;
uniform sampler2D u_texture;
uniform float u_gamma;

out vec4 FragColor;

void main()
{
	//we want to center the sample in the center of the pixel
	vec2 uv = v_uv + u_iRes * 0.5;
	vec3 color = texture( u_texture, v_uv ).xyz;
	color = pow(color,vec3(1.0/u_gamma));

	FragColor = vec4(color, 1.0);
}


\tone_mapper.fs

#version 330 core

in vec2 v_uv;

uniform vec2 u_iRes;
uniform sampler2D u_texture;
uniform float u_average_lum;
uniform float u_lumwhite2;
uniform float u_igamma;
uniform float u_scale;

out vec4 FragColor;

vec3 RGB2xyY (vec3 rgb)
{
	const mat3 RGB2XYZ = mat3(0.4124, 0.3576, 0.1805,
							  0.2126, 0.7152, 0.0722,
							  0.0193, 0.1192, 0.9505);
	vec3 XYZ = RGB2XYZ * rgb;
	float f = (XYZ.x + XYZ.y + XYZ.z);

	return vec3(XYZ.x / f, XYZ.y / f, XYZ.y);
}

void main() {
	vec2 uv = v_uv + u_iRes * 0.5;
	vec4 color = texture(u_texture, uv);
	vec3 rgb = color.xyz;

	float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));
	float L = (u_scale / u_average_lum) * lum;
	float Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);

	rgb = (rgb / lum) * Ld;
	rgb = max(rgb,vec3(0.001));
	rgb = pow( rgb, vec3( u_igamma ) );

	FragColor = vec4( rgb, color.a );
}


\probe.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;

uniform vec3 u_coeffs[9];

out vec4 FragColor;

#include "SHfunctions"

void main()
{
	vec3 N = normalize(v_normal);

	SH9Color sh;
	sh.c[0] = u_coeffs[0];
	sh.c[1] = u_coeffs[1];
	sh.c[2] = u_coeffs[2];
	sh.c[3] = u_coeffs[3];
	sh.c[4] = u_coeffs[4];
	sh.c[5] = u_coeffs[5];
	sh.c[6] = u_coeffs[6];
	sh.c[7] = u_coeffs[7];
	sh.c[8] = u_coeffs[8];

	vec4 color = vec4(ComputeSHIrradiance(N, sh), 1.0);

	FragColor = color;
}

\skybox.fs

#version 330 core

in vec3 v_world_position;

uniform vec4 u_color;
uniform samplerCube u_environment_texture;
uniform vec3 u_camera_position;

out vec4 FragColor;

void main()
{
	vec3 V = v_world_position - u_camera_position;
	//-V to void being upside down
	vec4 color = texture( u_environment_texture, V );

	FragColor = color;
}


\reflection.fs

#version 330 core

in vec3 v_world_position;
in vec3 v_normal;

uniform vec4 u_color;
uniform samplerCube u_texture;
uniform vec3 u_camera_position;

out vec4 FragColor;

void main()
{
	vec3 V = v_world_position - u_camera_position;
	vec3 N = normalize(v_normal);
	vec3 R = reflect(V,N);

	vec4 color = texture( u_texture, R );

	FragColor = color;
}


\volume_direct.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_extra_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_shadowmap_texture;

uniform vec2 u_iRes;
uniform vec3 u_camera_position;

uniform mat4 u_inverse_viewprojection;

#include "lightUniforms"
#include "lightFunctions"

out vec4 FragColor;

#define SAMPLES 64

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	//vec2 uv = v_uv;

	//reconstruct world position
	float depth = texture( u_depth_texture, uv ).x;
	vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
	//convert clip space coordinate to world position
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;


	//volumetric variables
	vec3 current_pos = u_camera_position;
	vec3 ray_dir = world_position - u_camera_position;
	float dist = length( ray_dir );
	if(dist > 1000)
		dist = 1000;
	ray_dir /= dist;
	float step_dist = dist / float(SAMPLES);
	float transparency = 1.0;
	float air_density = 0.001;
	vec3 ray_offset = ray_dir * step_dist;
	vec3 color = vec3(0.0);

	for(int i = 0; i < SAMPLES; i++)
	{
		float pixel_transparency = air_density * step_dist;
		transparency -= pixel_transparency;

		float shadow_factor = 0.0;
		if (u_cast_shadow)
		{
			shadow_factor = computeShadowFactor(current_pos, u_shadow_viewproj, u_shadow_bias, u_shadowmap_texture, u_light_type );
		}
		color += shadow_factor * u_light_color * pixel_transparency;

		if(transparency < 0.001)
			break;

		//advance position
		current_pos.xyz += ray_offset;
	}
	FragColor = vec4(color, transparency);
	//FragColor = vec4(1.0,0.0,0.0,1.0);
}


\decals.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_extra_texture;
uniform sampler2D u_depth_texture;

uniform sampler2D u_decal_texture;

uniform mat4 u_inverse_viewprojection;
uniform vec2 u_iRes;
uniform mat4 u_iModel;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;
layout(location = 2) out vec4 ExtraColor;

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	vec4 albedo = texture( u_color_texture, uv );
	vec4 normal = texture( u_normal_texture, uv);
	vec4 extra = texture( u_extra_texture, uv);

	vec3 N = normalize(normal.xyz * 2.0 - vec3(1.0));
	
	//reconstruct world position from depth and inv. viewproj
	float depth = texture( u_depth_texture, uv ).x;
	//convert in range -1 .. 1
	vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
	//convert clip space coordinate to world position
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;

	vec3 localpos = (u_iModel * vec4(world_position,1.0)).xyz;

	uv = (localpos.xz / 2.0) + vec2(0.5);
	if( uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)
		discard;
	
	vec4 decal = texture(u_decal_texture, uv);

	if(decal.a < 0.5)
		discard;

	//albedo.xyza = vec4(1.0,0,0, 1.0);
	albedo.xyz = decal.xyz;
	FragColor = albedo;
	NormalColor = normal;
	ExtraColor = extra;
}

\irradiance.fs

#version 330 core

uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_extra_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_probes_texture;
uniform mat4 u_inverse_viewprojection;
uniform vec2 u_iRes;

uniform vec3 u_irr_start;
uniform vec3 u_irr_end;
uniform vec3 u_irr_dims; 
uniform vec3 u_irr_delta;
uniform float u_num_probes;
uniform float u_irr_normal_distance;

out vec4 FragColor;

#include "SHfunctions"
#include "irradianceFunctions"

void main()
{	
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	vec4 albedo = texture( u_color_texture, uv );
	vec4 normal = texture( u_normal_texture, uv);
	vec4 extra = texture( u_extra_texture, uv);
	
	vec3 N = normalize(normal.xyz * 2.0 - vec3(1.0));
		
	//reconstruct world position from depth and inv. viewproj
	float depth = texture( u_depth_texture, uv ).x;
	//convert in range -1 .. 1
	vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
	//convert clip space coordinate to world position
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;

	vec3 irradiance = computeIrradianceInterpolated( world_position, N );
	
	FragColor = vec4(irradiance, 1.0);
}

\motion_blur.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform sampler2D u_depth_texture;

uniform vec2 u_iRes;

uniform mat4 u_inverse_viewprojection;
uniform mat4 u_prev_vp;

out vec4 FragColor;

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	//vec2 uv = v_uv;

	//reconstruct world position
	float depth = texture( u_depth_texture, uv ).x;
	vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
	//convert clip space coordinate to world position
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;

	vec4 old_screenpos = u_prev_vp * vec4(world_position, 1.0);
	old_screenpos.xyz /= old_screenpos.w;
	vec2 uv_old = old_screenpos.xy * 0.5 + vec2(0.5);

	//vec3 color = vec3(old_screenpos.xyz * 0.5 + vec3(0.5));
	vec3 color = vec3(0.0);
	//interpolation
	for ( int i= 0; i < 16; i++)
	{
		float factor = float(i) / 16.0;
		vec2 uv_temp = mix(uv, uv_old, factor);
		color += texture(u_texture, uv_temp).xyz;
	}
	color /= 16.0;
	FragColor = vec4(color, 1.0);
}

\pixelated.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform vec2 u_iRes;
uniform int u_pixel_size;

out vec4 FragColor;

void main()
{
	//u_pixel_size needs to be odd

	vec2 uv = gl_FragCoord.xy * u_iRes.xy;

	vec2 texSize  = textureSize(u_texture, 0).xy;
	vec2 texCoord = uv / texSize;

	float x = int(gl_FragCoord.x) % u_pixel_size;
	float y = int(gl_FragCoord.y) % u_pixel_size;

	x = floor(u_pixel_size / 2.0) - x;
	y = floor(u_pixel_size / 2.0) - y;

	x += gl_FragCoord.x;
	y += gl_FragCoord.y;

	vec2 new_uv = vec2(x,y) / texSize;
	vec4 color = texture(u_texture, new_uv);

	FragColor = color;
}

\blur.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform vec2 u_iRes;
uniform int u_blur_size;

out vec4 FragColor;

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;

	vec4 color = vec4(0.0);
	
	if (u_blur_size == 0) {
		//no blur
		color = texture(u_texture, uv);
	} else {
		int cnt = 0;
		for (int i = -u_blur_size; i <= u_blur_size; ++i) {
			for (int j = -u_blur_size; j <= u_blur_size; ++j) {
				color += texture(u_texture, (gl_FragCoord.xy + vec2(i,j)) * u_iRes.xy);
				cnt += 1;
			}
		}

		color /= cnt;
	}

	FragColor = color;
}


\dof.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform sampler2D u_blur_texture;
uniform sampler2D u_depth_texture;
uniform vec2 u_iRes;
uniform int u_blur_size;
uniform vec2 u_camera_nearfar;

out vec4 FragColor;

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;

	vec4 color = vec4(0.0);
	
	vec2 texSize  = textureSize(u_texture, 0).xy;

	float depth = texture( u_depth_texture, uv ).x;
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_depth_texture,v_uv).x;
	float color_depth = n * (z + 1.0) / (f + n - z * (f - n));

	if(color_depth > 0.09) {
		color = mix( texture(u_blur_texture, uv), texture(u_texture, uv), 0.2);
	} else {
		color = mix( texture(u_texture, uv), texture(u_blur_texture, uv), 0.2);
	}

	FragColor = color;
}


\grain.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform vec2 u_iRes;
uniform float u_strength;
uniform float u_time;

out vec4 FragColor;

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	vec4 color = texture(u_texture, uv);
    
    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (u_time * 10.0);
	vec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * u_strength;
    
	FragColor = color + grain;
}


\chromatic.fs
#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform vec2 u_iRes;
uniform float u_lens_distortion;

out vec4 FragColor;

vec2 barrelDistortion(vec2 coord, float amt) {
	vec2 cc = coord - 0.5;
	float dist = dot(cc, cc);
	return coord + cc * dist * amt;
}

float sat( float t )
{
	return clamp( t, 0.0, 1.0 );
}

float linterp( float t ) {
	return sat( 1.0 - abs( 2.0*t - 1.0 ) );
}

float remap( float t, float a, float b ) {
	return sat( (t - a) / (b - a) );
}

vec4 spectrum_offset( float t ) {
	vec4 ret;
	float lo = step(t,0.5);
	float hi = 1.0-lo;
	float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );
	ret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);

	return pow( ret, vec4(1.0/2.2) );
}

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;

	vec4 sumcol = vec4(0.0);
	vec4 sumw = vec4(0.0);	

	float max_distort = 2.2;
	int num_iter = 12;
	float reci_num_iter_f = 1.0 / float(num_iter);

	for ( int i=0; i<num_iter;++i )
	{
		float t = float(i) * reci_num_iter_f;
		vec4 w = spectrum_offset( t );
		sumw += w;
		sumcol += w * texture( u_texture, barrelDistortion(uv, u_lens_distortion * max_distort*t ) );
	}

	FragColor = sumcol/sumw;
}

\lens.fs
#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform vec2 u_iRes;
uniform float u_lens_distortion;

out vec4 FragColor;

vec2 barrelDistortion(vec2 coord, float amt) {
	vec2 cc = coord - 0.5;
	float dist = dot(cc, cc);
	return coord + cc * dist * amt;
}

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	vec2 uv_barrel = barrelDistortion(uv, u_lens_distortion);
	vec3 color = vec3(0.0);
	if( uv_barrel.x >= 0.0 && uv_barrel.x <= 1.0 && uv_barrel.y >= 0.0 && uv_barrel.y <= 1.0 ) {
		color = texture(u_texture, uv_barrel).xyz;
	}
	FragColor = vec4( color, 1.0 );
}


\bloom.fs
#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform sampler2D u_blur_texture;
uniform vec2 u_iRes;
uniform vec2 u_camera_nearfar;
uniform float u_threshold;
uniform float u_soft_threshold;
uniform float u_intensity;

out vec4 FragColor;

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;

	int   size       = 5;
	float separation = 4.0;
	float threshold  = 0.5;
	float amount     = 0.5;

	vec4 result = vec4(0.0);
  	vec4 color  = vec4(0.0);
	vec2 texSize = textureSize(u_texture, 0).xy;

	float value = 0.0;
  	float count = 0.0;

	for (int i = -size; i <= size; ++i) {
		for (int j = -size; j <= size; ++j) {
			color = texture( u_texture, (vec2(i, j) * separation + gl_FragCoord.xy) / texSize );

			value = max(color.r, max(color.g, color.b));
			if (value < threshold) { color = vec4(0.0); }

			result += color;
			count  += 1.0;
		}
	}

	result /= count;

	vec3 c= texture(u_texture, uv).xyz;
	float brightness = max(c.r, max(c.g, c.b));
	float knee = u_threshold * u_soft_threshold;
	float soft = brightness - u_threshold + knee;
	soft = clamp(soft, 0, 2 * knee);
	soft = soft * soft / (4 * knee + 0.00001);
	float contribution = max(soft, brightness - u_threshold);
	contribution /= max(brightness, 0.00001);

	FragColor = u_intensity * mix( vec4( c * contribution, 1.0 ) , result, amount);
	//FragColor =  vec4( u_intensity *c * contribution, 1.0 );
	//FragColor = mix( texture(u_texture, uv), result, amount);
}


\lut.fs
#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform sampler2D u_lut_texture;
uniform vec2 u_iRes;
uniform float u_amount;

out vec4 FragColor;

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	vec4 color = clamp( texture(u_texture, uv), vec4(0.0), vec4(1.0) );

	float blueColor = color.b * 63.0;
	
	vec2 quad1;
	quad1.y = floor( floor( blueColor ) / 8.0 );
	quad1.x = floor( blueColor ) - ( quad1.y * 8.0 );

	vec2 quad2;
	quad2.y = floor( ceil( blueColor ) / 8.0 );
	quad2.x = ceil( blueColor ) - ( quad2.y * 8.0 );

	vec2 texPos1;
	texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);
	texPos1.y = 1.0 - ((quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g ));

	vec2 texPos2;
	texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);
	texPos2.y = 1.0 - ((quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g));

	vec4 newColor1 = texture( u_lut_texture, texPos1 );
	vec4 newColor2 = texture( u_lut_texture, texPos2 );
	vec4 newColor = mix( newColor1, newColor2, fract(blueColor) );

	FragColor = vec4( mix( color.rgb, newColor.rgb, u_amount), color.w);
}


\fxaa.fs
#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform vec2 u_iRes;

out vec4 FragColor;

#define FXAA_REDUCE_MIN (1.0/ 128.0)
#define FXAA_REDUCE_MUL (1.0 / 8.0)
#define FXAA_SPAN_MAX 8.0

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	vec2 fragCoord = uv;
	vec2 u_iViewportSize = u_iRes;

	vec4 color = vec4(0.0);
	vec3 rgbNW = texture( u_texture, (fragCoord + vec2(-1.0, -1.0)) * u_iViewportSize).xyz;
	vec3 rgbNE = texture( u_texture, (fragCoord + vec2(1.0, -1.0)) * u_iViewportSize).xyz;
	vec3 rgbSW = texture( u_texture, (fragCoord + vec2(-1.0, 1.0)) * u_iViewportSize).xyz;
	vec3 rgbSE = texture( u_texture, (fragCoord + vec2(1.0, 1.0)) * u_iViewportSize).xyz;
	vec3 rgbM  = texture( u_texture, fragCoord  * u_iViewportSize).xyz;
	
	vec3 luma = vec3(0.299, 0.587, 0.114);
	float lumaNW = dot(rgbNW, luma);
	float lumaNE = dot(rgbNE, luma);
	float lumaSW = dot(rgbSW, luma);
	float lumaSE = dot(rgbSE, luma);
	float lumaM  = dot(rgbM,  luma);
	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

	vec2 dir;
	dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
	dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

	float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

	float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
	dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * u_iViewportSize;

	vec3 rgbA = 0.5 * (texture( u_texture, fragCoord * u_iViewportSize + dir * (1.0 / 3.0 - 0.5)).xyz + texture( u_texture, fragCoord * u_iViewportSize + dir * (2.0 / 3.0 - 0.5)).xyz);
	vec3 rgbB = rgbA * 0.5 + 0.25 * (texture( u_texture, fragCoord * u_iViewportSize + dir * -0.5).xyz + texture( u_texture, fragCoord * u_iViewportSize + dir * 0.5).xyz);


	float lumaB = dot(rgbB, luma);
	if ((lumaB < lumaMin) || (lumaB > lumaMax))
		color = vec4(rgbA, 1.0);
	else
		color = vec4(rgbB, 1.0);

	FragColor = color;
}


\sharpen.fs
#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform vec2 u_iRes;
uniform float u_amount_contrast;

out vec4 FragColor;

void main()
{
	vec2 texSize   = textureSize(u_texture, 0).xy;
	vec2 fragCoord = gl_FragCoord.xy;
	vec2 texCoord  = fragCoord / texSize;

	float neighbour = u_amount_contrast * -1.0;
	float center   = u_amount_contrast *  4.0 + 1.0;

	vec3 color =
		  texture( u_texture, (fragCoord + vec2( 0,  1)) / texSize ).rgb * neighbour
		+ texture( u_texture, (fragCoord + vec2(-1,  0)) / texSize ).rgb * neighbour
		+ texture( u_texture, (fragCoord + vec2( 0,  0)) / texSize ).rgb * center
		+ texture( u_texture, (fragCoord + vec2( 1,  0)) / texSize ).rgb * neighbour
		+ texture( u_texture, (fragCoord + vec2( 0, -1)) / texSize ).rgb * neighbour;

	FragColor = vec4( color, texture(u_texture, texCoord).a );
}